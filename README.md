# docker-on-linux

- [docker-on-linux](#docker-on-linux)
  - [Introduction](#introduction)
  - [Documentation](#documentation)
  - [Installation](#installation)
    - [Option A - Manual Provisioning](#option-a---manual-provisioning)
      - [Create Virtual Machine](#create-virtual-machine)
      - [Uninstall old versions](#uninstall-old-versions)
      - [Set up the repository](#set-up-the-repository)
      - [Install Docker Engine](#install-docker-engine)
      - [Start Dockear daemon](#start-dockear-daemon)
      - [Adding User to docker group](#adding-user-to-docker-group)
      - [Enable Docker service on boot](#enable-docker-service-on-boot)
      - [Verification](#verification)
    - [Option B - Bash Provisioning](#option-b---bash-provisioning)
      - [Create Virtual Machine](#create-virtual-machine-1)
    - [Option C - Ansible Provisioning](#option-c---ansible-provisioning)
      - [Create Virtual Machine](#create-virtual-machine-2)
  - [Docker Contexts](#docker-contexts)
    - [Namespaces](#namespaces)
    - [Contexts](#contexts)
    - [Docker Snap](#docker-snap)
    - [Docker Binaries](#docker-binaries)
    - [Docker remote connection](#docker-remote-connection)
      - [Running remote containers](#running-remote-containers)
  - [Securing Remote Access](#securing-remote-access)
    - [Using Unix Socket with SSH](#using-unix-socket-with-ssh)
    - [Using TCP Socket without TLS](#using-tcp-socket-without-tls)
    - [Using TCP Socket with TLS](#using-tcp-socket-with-tls)
      - [Configuring CA](#configuring-ca)
      - [Managing Certificates](#managing-certificates)
      - [Configuring docker deamon](#configuring-docker-deamon)
      - [Testing locally with docker client](#testing-locally-with-docker-client)
      - [Testing locally with curl](#testing-locally-with-curl)
      - [Testing remotely with docker client](#testing-remotely-with-docker-client)
      - [Testing remotely with curl](#testing-remotely-with-curl)
      - [Creating docker context](#creating-docker-context)

## Introduction

## Documentation

- [Namespaces](https://man7.org/linux/man-pages/man7/namespaces.7.html)
- [Nsenter](https://man7.org/linux/man-pages/man1/nsenter.1.html)
- [Docker Hub](https://hub.docker.com/)
- [Docker Binaries](https://docs.docker.com/engine/install/binaries/)
- [Snapcraft Docker](https://snapcraft.io/docker)


## Installation

In order to create Virtual Machines in declarative way, using VagrantFile, you first need to install the tool itself and a hypervisor of your choice.

- [Vagrant Project](https://www.vagrantup.com/)
- [VirtualBox](https://www.virtualbox.org/)
- [Hyper-V on Windows 10](https://docs.microsoft.com/en-us/virtualization/hyper-v-on-windows/quick-start/enable-hyper-v)

Since I am using a Windows environment with [WSL2](https://devblogs.microsoft.com/commandline/wsl2-will-be-generally-available-in-windows-10-version-2004/) enabled. I will describe the steps using Hyper-V as hypervisor provider for Vagrant.

### Option A - Manual Provisioning

#### Create Virtual Machine

Start by initializing the Vagrantfile with default values using the official [Centos 7 Vagrant box](https://app.vagrantup.com/centos/boxes/7). 

```bash
cd installation/centos-7
vagrant init centos/7
vagrant up
Bringing machine 'default' up with 'hyperv' provider...
==> default: Verifying Hyper-V is enabled...
==> default: Verifying Hyper-V is accessible...
==> default: Box 'centos/7' could not be found. Attempting to find and install...
    default: Box Provider: hyperv
    default: Box Version: >= 0
==> default: Loading metadata for box 'centos/7'
    default: URL: https://vagrantcloud.com/centos/7
==> default: Adding box 'centos/7' (v2004.01) for provider: hyperv
    default: Downloading: https://vagrantcloud.com/centos/boxes/7/versions/2004.01/providers/hyperv.box
Download redirected to host: cloud.centos.org
Progress: 2% (Rate: 3825k/s, Estimated time remaining: 0:02:29)
[ Output omitted for brevity]
```

Once the box is up and running, use `vagrant ssh` which is a wrapper that leverages SSH configuration that was generated by Vagrant. Details are available at `vagrant ssh-config`.

```bash
vagrant ssh
# Verify user
[vagrant@localhost ~]$ id
uid=1000(vagrant) gid=1000(vagrant) groups=1000(vagrant) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023
[vagrant@localhost ~]$ groups
vagrant
# Verify release
[vagrant@localhost ~]$ cat /etc/*release
CentOS Linux release 7.8.2003 (Core)
NAME="CentOS Linux"
VERSION="7 (Core)"
ID="centos"
ID_LIKE="rhel fedora"
VERSION_ID="7"
PRETTY_NAME="CentOS Linux 7 (Core)"
ANSI_COLOR="0;31"
CPE_NAME="cpe:/o:centos:centos:7"
HOME_URL="https://www.centos.org/"
BUG_REPORT_URL="https://bugs.centos.org/"

CENTOS_MANTISBT_PROJECT="CentOS-7"
CENTOS_MANTISBT_PROJECT_VERSION="7"
REDHAT_SUPPORT_PRODUCT="centos"
REDHAT_SUPPORT_PRODUCT_VERSION="7"

CentOS Linux release 7.8.2003 (Core)
CentOS Linux release 7.8.2003 (Core)
```

To install Docker, we are going to follow the [Install Docker Engine on CentOS](https://docs.docker.com/engine/install/centos/). From the guest shell follow these procedures to install docker on Centos 7.

#### Uninstall old versions

```bash
sudo yum remove docker \
                  docker-client \
                  docker-client-latest \
                  docker-common \
                  docker-latest \
                  docker-latest-logrotate \
                  docker-logrotate \
                  docker-engine
```

#### Set up the repository

```bash
sudo yum install -y yum-utils
sudo yum-config-manager \
    --add-repo \
    https://download.docker.com/linux/centos/docker-ce.repo
```

#### Install Docker Engine

Install the `docker-ce`, `docker-ce-cli` and `containerd.io`.
```bash
sudo yum install -y docker-ce docker-ce-cli containerd.io
```

Verify the that `docker` command is available.
```bash
docker version
Client: Docker Engine - Community
 Version:           20.10.3
 API version:       1.41
 Go version:        go1.13.15
 Git commit:        48d30b5
 Built:             Fri Jan 29 14:34:14 2021
 OS/Arch:           linux/amd64
 Context:           default
 Experimental:      true
Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?
```

Verify that the docker deamon is running.
```bash
ls /var/run | grep docker.sock

# Check service status using system manager
systemctl status docker.service
● docker.service - Docker Application Container Engine
   Loaded: loaded (/usr/lib/systemd/system/docker.service; disabled; vendor preset: disabled)
   Active: inactive (dead)
     Docs: https://docs.docker.com

systemctl status docker.socket
● docker.socket - Docker Socket for the API
   Loaded: loaded (/usr/lib/systemd/system/docker.socket; disabled; vendor preset: disabled)
   Active: inactive (dead)
   Listen: /var/run/docker.sock (Stream)
```

#### Start Dockear daemon

```bash
sudo systemctl start docker
# Rerun the systemctl status for docker.service and docker.host to verify that both services are running
systemctl status docker.service
● docker.service - Docker Application Container Engine
   Loaded: loaded (/usr/lib/systemd/system/docker.service; disabled; vendor preset: disabled)
   Active: active (running) since Wed 2021-02-17 13:37:54 UTC; 1min 42s ago
     Docs: https://docs.docker.com
 Main PID: 20902 (dockerd)
    Tasks: 8
   Memory: 43.5M
   CGroup: /system.slice/docker.service
           └─20902 /usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock

systemctl status docker.socket
● docker.socket - Docker Socket for the API
   Loaded: loaded (/usr/lib/systemd/system/docker.socket; disabled; vendor preset: disabled)
   Active: active (running) since Wed 2021-02-17 13:37:53 UTC; 1min 46s ago
   Listen: /var/run/docker.sock (Stream)
```

As you see from above output the socket `/var/run/docker.sock` is now available. You can verify that also using:
```bash
ls /var/run | grep docker.sock
docker.sock
```

Now back to `docker version` the output is different and indicates that the current user does not have permissions to access the socket.
```bash
docker version
Client: Docker Engine - Community
 Version:           20.10.3
 API version:       1.41
 Go version:        go1.13.15
 Git commit:        48d30b5
 Built:             Fri Jan 29 14:34:14 2021
 OS/Arch:           linux/amd64
 Context:           default
 Experimental:      true
Got permission denied while trying to connect to the Docker daemon socket at unix:///var/run/docker.sock: Get http://%2Fvar%2Frun%2Fdocker.sock/v1.24/version: dial unix /var/run/docker.sock: connect: permission denied
```

The reason is that the socket permissins does not allow `vagrant:vagrant` to access it.
```
ls -al /var/run/docker.sock
srw-rw----. 1 root docker 0 Feb 17 13:37 /var/run/docker.sock
```

To fix this, we have two available options:
- Elavate permissions using `sudo` everytime `docker` is invoked
- Add `vagrant` user to `docker` group.

Lets perform the second option.

#### Adding User to docker group

```bash
sudo usermod -aG docker vagrant
```

You need to logout and login to apply this change
```bash
# Verify the user groups
groups
vagrant docker
```

With this change, user has proper access to invoke `docker version` and retrieve information for client and server.
```bash
[vagrant@localhost ~]$ groups
vagrant docker
[vagrant@localhost ~]$ docker version
Client: Docker Engine - Community
 Version:           20.10.3
 API version:       1.41
 Go version:        go1.13.15
 Git commit:        48d30b5
 Built:             Fri Jan 29 14:34:14 2021
 OS/Arch:           linux/amd64
 Context:           default
 Experimental:      true

Server: Docker Engine - Community
 Engine:
  Version:          20.10.3
  API version:      1.41 (minimum version 1.12)
  Go version:       go1.13.15
  Git commit:       46229ca
  Built:            Fri Jan 29 14:32:37 2021
  OS/Arch:          linux/amd64
  Experimental:     false
 containerd:
  Version:          1.4.3
  GitCommit:        269548fa27e0089a8b8278fc4fc781d7f65a939b
 runc:
  Version:          1.0.0-rc92
  GitCommit:        ff819c7e9184c13b7c2607fe6c30ae19403a7aff
 docker-init:
  Version:          0.19.0
  GitCommit:        de40ad0
```

#### Enable Docker service on boot

Verify the current state and configuration summary of systemctl unit-files for docker:
```bash
systemctl list-unit-files | grep docker
docker.service                                disabled
docker.socket                                 disabled
```

To enable both services update the systemctl configuration.
```bash
sudo systemctl enable docker
Created symlink from /etc/systemd/system/multi-user.target.wants/docker.service to /usr/lib/systemd/system/docker.service.

# You can verify that docker.socket and containerd.service are dependencies for docker.service
cat /etc/systemd/system/multi-user.target.wants/docker.service | grep Requires
Requires=docker.socket containerd.service
```

To verify the which unit files are related to docker packages you can use `rpm -ql docker-ce`.
```bash
rpm -ql docker-ce
/usr/bin/docker-init
/usr/bin/docker-proxy
/usr/bin/dockerd
/usr/lib/systemd/system/docker.service
/usr/lib/systemd/system/docker.socket
```

You can use this method for other packages that were installed previously.

#### Verification

Reload the VM in order to make sure that docker deamon will start automatically. Use `vagrant reload` from the Host machine.
Once the machie boots, access it ssh and execute `docker version`.
```
vagrant reload
```


### Option B - Bash Provisioning

#### Create Virtual Machine

Start by initializing the Vagrantfile with default values using the [Centos 8 Vagrant box](https://app.vagrantup.com/centos/boxes/8)provided by generic. 

```bash
cd installation/centos-8
vagrant init centos/8
```

Open your favorite code editor and configure provisioning option in Vagrantfile.

```ruby
Vagrant.configure("2") do |config|
  config.vm.box = "centos/8"
  config.vm.provision "shell", path: "provision.sh"
```

Save the file, and create a new file `provision.sh` in same directory. You can leverage the script that is available at [get.docker](https://get.docker.com/) or you can write your own custom script. One modifycation I made was to start service automatically.

With both files ready, start with `vagrant up`.

```bash
vagrant up
Bringing machine 'default' up with 'hyperv' provider...                                                                              ==> default: Verifying Hyper-V is enabled...
==> default: Verifying Hyper-V is accessible...
==> default: Importing a Hyper-V instance
    default: Creating and registering the VM...
    default: Successfully imported VM
[ Output omitted for brevity]
==> default: Machine booted and ready!
==> default: Running provisioner: shell...
    default: Running: /tmp/vagrant-shell20210217-18571-ai2mvr.sh
    default: # Executing docker install script, commit: 3d8fe77c2c46c5b7571f94b42793905e5b3e42e4
    default: + sh -c 'yum install -y -q yum-utils'
    default: + sh -c 'yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo'
    default: Adding repo from: https://download.docker.com/linux/centos/docker-ce.repo
    default: + '[' stable '!=' stable ']'
    default: + sh -c 'yum makecache'
    default: CentOS Linux 8 - AppStream                       26 kB/s | 4.3 kB     00:00
    default: CentOS Linux 8 - BaseOS                          23 kB/s | 3.9 kB     00:00
    default: CentOS Linux 8 - Extras                         8.7 kB/s | 1.5 kB     00:00
    default: Docker CE Stable - x86_64                        30 kB/s | 9.2 kB     00:00
    default: Extra Packages for Enterprise Linux Modular 8 - 122 kB/s |  33 kB     00:00
    default: Extra Packages for Enterprise Linux 8 - x86_64   93 kB/s |  23 kB     00:00
    default: Metadata cache created.
```

Once the box is up and running, use `vagrant ssh` and verify that docker was sucessfully installed.

```bash
vagrant ssh
docker version
Client: Docker Engine - Community
 Version:           20.10.3
 API version:       1.41
 Go version:        go1.13.15
 Git commit:        48d30b5
 Built:             Fri Jan 29 14:33:08 2021
 OS/Arch:           linux/amd64
 Context:           default
 Experimental:      true

Server: Docker Engine - Community
 Engine:
  Version:          20.10.3
  API version:      1.41 (minimum version 1.12)
  Go version:       go1.13.15
  Git commit:       46229ca
  Built:            Fri Jan 29 14:31:25 2021
  OS/Arch:          linux/amd64
  Experimental:     false
 containerd:
  Version:          1.4.3
  GitCommit:        269548fa27e0089a8b8278fc4fc781d7f65a939b
 runc:
  Version:          1.0.0-rc92
  GitCommit:        ff819c7e9184c13b7c2607fe6c30ae19403a7aff
 docker-init:
  Version:          0.19.0
  GitCommit:        de40ad0
```


### Option C - Ansible Provisioning

#### Create Virtual Machine

Start by initializing the Vagrantfile with default values using the [Ubuntu 20.04 Vagrant box](https://app.vagrantup.com/generic/boxes/ubuntu2004) provided by geenric. 

```bash
cd installation/ubuntu-20.04
vagrant init generic/ubuntu2004
```

Open your favorite code editor and configure provisioning option in Vagrantfile.

```ruby
Vagrant.configure("2") do |config|
  config.vm.box = "centos/8"
  config.vm.provision "ansible" do |ansible|
    ansible.playbook = "playbook.yml"
```

Save the file, and create a new file `playbook.yml` in same directory. 

```yml

```

It is good practice to verify the playbook syntax with `ansible-playbook playbook.yml --syntax-check`.
```bash
[WARNING]: provided hosts list is empty, only localhost is available. Note that the implicit localhost does not match 'all'

playbook: playbook.yml
```

With both files ready, start with `vagrant up`.

```bash
vagrant up
Bringing machine 'default' up with 'hyperv' provider...
==> default: Verifying Hyper-V is enabled...
==> default: Verifying Hyper-V is accessible...
==> default: Importing a Hyper-V instance
[ Output omitted for brevity]
==> default: Machine booted and ready!
==> default: Running provisioner: ansible...
    default: Running ansible-playbook...

PLAY [all] *********************************************************************

TASK [Gathering Facts] *********************************************************
ok: [default]

TASK [install prerequisites] ***************************************************
changed: [default]

TASK [add apt-key] *************************************************************
changed: [default]

TASK [add docker repo] *********************************************************
changed: [default]

TASK [install docker] **********************************************************
changed: [default]

TASK [add userpermissions] *****************************************************
changed: [default]

PLAY RECAP *********************************************************************
default                    : ok=6    changed=4    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0
```

Once the box is up and running, use `vagrant ssh` and verify that docker was sucessfully installed.

```bash
vagrant ssh
docker version
Client: Docker Engine - Community
 Version:           20.10.3
 API version:       1.41
 Go version:        go1.13.15
 Git commit:        48d30b5
 Built:             Fri Jan 29 14:33:21 2021
 OS/Arch:           linux/amd64
 Context:           default
 Experimental:      true

Server: Docker Engine - Community
 Engine:
  Version:          20.10.3
  API version:      1.41 (minimum version 1.12)
  Go version:       go1.13.15
  Git commit:       46229ca
  Built:            Fri Jan 29 14:31:32 2021
  OS/Arch:          linux/amd64
  Experimental:     false
 containerd:
  Version:          1.4.3
  GitCommit:        269548fa27e0089a8b8278fc4fc781d7f65a939b
 runc:
  Version:          1.0.0-rc92
  GitCommit:        ff819c7e9184c13b7c2607fe6c30ae19403a7aff
 docker-init:
  Version:          0.19.0
  GitCommit:        de40ad0
```


## Docker Contexts

Before we start with Docker contexts, lets understand the path that docker command takes to execute action upon a container. By default the following components will be involved:

1. docker command
2. Unix socket (IPC) to API, root:docker
3. Docker Engine API (Create container, list images, etc.)
4. Docker Engine daemon (dockerd) executes incomming API task / queries
5. Containers (isolated processes) and associated resources such as: images, mounts/filesystems, networking, processes, cgroups, security

Since the architecture is modular, it is possible to use multiple docker enginer API behind an Unix or TCP socket and therefore provide remote access to multiple (local, test, prod) docker engine daemons. Before doing so, lets review the fundamental building block of containers - linux namespaces.

### Namespaces

In summary, Docker provides a level of abstraction for underlying linux features such as namespaces. To work with namespaces directly, first create a new container inside previously provisioned Vagrant machine with docker installed.
```bash
docker run --rm -it bash
```
You will end up inside a docker container. Leave this terminal window open.

Back on VM with docker installed, open a new terminal and explore the use of `nsenter` command.
```bash
# Retrieve the Process ID for Container ID 3af2....
sudo docker inspect --format {{.State.Pid}} 3af2
7071
# Enter the namespace for target process 7071
sudo nsenter --target 7071 --mount --uts --ipc --net --pid /usr/local/bin/bash
```

### Contexts

Start by provisioning and verify a `cli-only` installation. 

```bash
cd installation/cli-only
vagrant up
[ Output omitted for brevity]
# Once the machine boots, login via vagrant ssh and verify the status,
docker info
Client:
 Context:    default
 Debug Mode: false
 Plugins:
  app: Docker App (Docker Inc., v0.9.1-beta3)
  buildx: Build with BuildKit (Docker Inc., v0.5.1-docker)

Server:
ERROR: Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?
errors pretty printing info
```

As expected, there is no docker daemon installed.

Provision and verify full docker install on `getdc`.

```bash
cd installation/getdc
vagrant up
[ Output omitted for brevity]
# Once the machine boots, login via vagrant ssh and verify the status,
docker info
Client: Docker Engine - Community
 Version:           20.10.3
 API version:       1.41
 Go version:        go1.13.15
 Git commit:        48d30b5
 Built:             Fri Jan 29 14:33:21 2021
 OS/Arch:           linux/amd64
 Context:           default
 Experimental:      true

Server: Docker Engine - Community
 Engine:
  Version:          20.10.3
  API version:      1.41 (minimum version 1.12)
  Go version:       go1.13.15
  Git commit:       46229ca
  Built:            Fri Jan 29 14:31:32 2021
  OS/Arch:          linux/amd64
  Experimental:     false
 containerd:
  Version:          1.4.3
  GitCommit:        269548fa27e0089a8b8278fc4fc781d7f65a939b
 runc:
  Version:          1.0.0-rc92
  GitCommit:        ff819c7e9184c13b7c2607fe6c30ae19403a7aff
 docker-init:
  Version:          0.19.0
  GitCommit:        de40ad0
  ```

Lets jump back to `cli-only` VM by using `vagrant ssh` in the correct folder. 

Verify the default docker context.

```bash
vagrant ssh
# Verify the context configuration
docker context ls
NAME        DESCRIPTION                               DOCKER ENDPOINT               KUBERNETES ENDPOINT   ORCHESTRATOR
default *   Current DOCKER_HOST based configuration   unix:///var/run/docker.sock                         swarm

# Inspect the context configuration
docker context inspect
[
    {
        "Name": "default",
        "Metadata": {
            "StackOrchestrator": "swarm"
        },
        "Endpoints": {
            "docker": {
                "Host": "unix:///var/run/docker.sock",
                "SkipTLSVerify": false
            }
        },
        "TLSMaterial": {},
        "Storage": {
            "MetadataPath": "\u003cIN MEMORY\u003e",
            "TLSPath": "\u003cIN MEMORY\u003e"
        }
    }
]
```

As you can see from above output, the default context points to Unix socket, which in this case is not available as we did not install docker daemon this machine.

Lets distroy these two machines by using `vagrant destroy --force`.

### Docker Snap

Docker is also available as [snap package](https://snapcraft.io/docker) provided by `snapcraft`. A Vagrantfile with the shell provision script is available at `installation/snappy` folder. Start the machine with `vagrant up`, once prepared enter the machine `vagrant ssh` and verify that docker is installed.

```bash
docker version
Client:
 Version:           19.03.13
 API version:       1.40
 Go version:        go1.13.15
 Git commit:        cd8016b6bc
 Built:             Fri Feb  5 15:56:39 2021
 OS/Arch:           linux/amd64
 Experimental:      false

Server:
 Engine:
  Version:          19.03.13
  API version:      1.40 (minimum version 1.12)
  Go version:       go1.13.15
  Git commit:       bd33bbf
...
[ Output omitted for brevity ]
...
```

### Docker Binaries

Installing docker engine from [binaries](https://docs.docker.com/engine/install/binaries/) is yet another way how to accomplish what we done in previous steps. 

A Vagrantfile with a shell provision script is avaibale in the `installation/binaries` folder. Start the machine with `vagrant up`, once prepared enter the machine `vagrant ssh`

You can change the default docker daemon configuration by adding arguments such as:
```bash
# Verify which argument deals with Deamon socket configuration
dockerd --help | grep Daemon
      --config-file string                      Daemon configuration file (default "/etc/docker/daemon.json")
  -H, --host list                               Daemon socket(s) to connect to

# Start the dockerd
sudo dockerd -H tcp://
...
[ Output omitted for brevity ]
...
INFO[2021-02-18T18:03:17.648802110Z] Daemon has completed initialization
INFO[2021-02-18T18:03:17.662811079Z] API listen on 127.0.0.1:2375
```

Using a different shell window, you can verify the connection locally.
```bash
# Verify version with Host option
docker -H tcp:// version
Client: Docker Engine - Community
 Version:           20.10.2
 API version:       1.41
 Go version:        go1.13.15
 Git commit:        2291f61
 Built:             Mon Dec 28 16:11:26 2020
 OS/Arch:           linux/amd64
 Context:           default
 Experimental:      true

Server: Docker Engine - Community
 Engine:
  Version:          20.10.2
  API version:      1.41 (minimum version 1.12)
  Go version:       go1.13.15
  Git commit:       8891c58
...
[ Output omitted for brevity ]
...
# Verify context with Host option
docker -H tcp:// context ls
NAME        DESCRIPTION                               DOCKER ENDPOINT        KUBERNETES ENDPOINT   ORCHESTRATOR
default *   Current DOCKER_HOST based configuration   tcp://localhost:2375                         swarm
```  

You can also use `DOCKER_HOST` variable with `docker` client like this:
```bash
# Using variable one time
DOCKER_HOST=tcp:// docker context ls
DOCKER_HOST=tcp:// docker version
```

The local connection over TCP at `127.0.0.1:2375` will now work. To enable remote connection, we need to change the configuration to bind to all addresses. Please note however this method is **insecure**.

```basg
sudo dockerd -H tcp://0.0.0.0:2375
...
[ Output omitted for brevity ]
...
INFO[2021-02-18T18:54:37.180895456Z] Daemon has completed initialization
INFO[2021-02-18T18:54:37.194794629Z] API listen on [::]:2375
```

### Docker remote connection

Back on `snappy` client machine, configure the `DOCKER_HOST` to point to remote `binaries` docker server. Then validate the connection.

```bash
# Update environment variable
export DOCKER_HOST=tcp://192.168.137.39:2375

# Verify that you can connect to remote docker server
docker version
Client:
 Version:           19.03.13
 API version:       1.40
 Go version:        go1.13.15
 Git commit:        cd8016b6bc
 Built:             Fri Feb  5 15:56:39 2021
 OS/Arch:           linux/amd64
 Experimental:      false

Server: Docker Engine - Community
 Engine:
  Version:          20.10.2
  API version:      1.41 (minimum version 1.12)
  Go version:       go1.13.15
  Git commit:       8891c58
  Built:            Mon Dec 28 16:15:23 2020
  OS/Arch:          linux/amd64
  Experimental:     false
 containerd:
  Version:          v1.4.3
  GitCommit:        269548fa27e0089a8b8278fc4fc781d7f65a939b
 runc:
  Version:          1.0.0-rc92
  GitCommit:        ff819c7e9184c13b7c2607fe6c30ae19403a7aff
 docker-init:
  Version:          0.19.0
  GitCommit:        de40ad0
```

#### Running remote containers

Now you can run container on remote docker server host using docker client on `snappy` machine.

```bash
# Run container on remote host
docker run --rm -d -p 8080:80 nginx
Unable to find image 'nginx:latest' locally
latest: Pulling from library/nginx
45b42c59be33: Pull complete
8acc495f1d91: Pull complete
ec3bd7de90d7: Pull complete
19e2441aeeab: Pull complete
f5a38c5f8d4e: Pull complete
83500d851118: Pull complete
Digest: sha256:f3693fe50d5b1df1ecd315d54813a77afd56b0245a404055a946574deb6b34fc
Status: Downloaded newer image for nginx:latest
8fa3f916772a2326a340a9f1935645b00f803ee1942dde4a4c222f9d7902610a

# Verify the container
curl --head 192.168.137.39:8080
HTTP/1.1 200 OK
Server: nginx/1.19.7
Date: Thu, 18 Feb 2021 19:02:59 GMT
Content-Type: text/html
Content-Length: 612
Last-Modified: Tue, 16 Feb 2021 15:57:18 GMT
Connection: keep-alive
ETag: "602beb5e-264"
Accept-Ranges: bytes
```

To avoid specifying connection details every time you invoke a docker command. You can create context for each connection. 

```bash
docker context create binaries --description "Remote testing environemnt" --docker "host=tcp://192.168.137.39:2375"
binaries
Successfully created context "binaries"

# Verify the new context
docker context ls
NAME                DESCRIPTION                               DOCKER ENDPOINT               KUBERNETES ENDPOINT   ORCHESTRATOR
binaries            Remote testing environemnt                tcp://192.168.137.39:2375
default *           Current DOCKER_HOST based configuration   unix:///var/run/docker.sock                         swarm
```

To to switch from `default` to `binaries` context, use the following command.
```bash
docker context use binaries
binaries
Current context is now "binaries"
```

Now every docker client command will by target to the remote docker host.
```bash
# Available images
docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
nginx               latest              35c43ace9216        24 hours ago        133MB

# Running containers
docker ps
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                  NAMES
8fa3f916772a        nginx               "/docker-entrypoint.…"   15 minutes ago      Up 15 minutes       0.0.0.0:8080->80/tcp   dreamy_williams

# Switch to default (local) context
docker context use default
default
Current context is now "default"
```

To export the newly created context, use `export` arguemnt.
```bash
docker context export binaries
Written file "binaries.dockercontext"

```
You can later import this connection.

## Securing Remote Access

### Using Unix Socket with SSH 

There are multiple ways how to secure access to dockerd deamon running on remote host. For example you can start daemon on server machine with default configuration and leverage SSH forwarding.
```bash
sudo dockerd 
...
[ Output omitted for brevity ]
...
INFO[2021-02-19T12:07:55.524810191Z] Daemon has completed initialization
INFO[2021-02-19T12:07:55.536084235Z] API listen on /var/run/docker.sock
```

Next, you need to copy and modify the ssh configration that was generated by Vagrant on host machine. machine:
```bash
cd installation/binaries
vagrant ssh-config > ~/.ssh/vagrants/binaries.config
```

*Tip: You can include this folder in the main host machine `~/.ssh/config` by adding `Include vagrants/*` on top your configuration.*

You can test the new setup with `ssh vagrant@binaries` command from host machine.
```bash
ssh vagrant@binaries
vagrant@binaries:~$
```

Now, back on host machines (assuming that you have docker client) installed, you can using `-H` option to specify remote docker server.

```bash
docker -H ssh://vagrant@binaries version
```


To create a docker context for such connection, you can execute the following on host machine.
```bash
docker context create binaries --docker "host=ssh://vagrant@binaries"
binaries
Successfully created context "binaries"

# Switch to newly created context
docker context use binaries

# Verify remote server configuration
docker version
Client: Docker Engine - Community
 Cloud integration: 1.0.7
 Version:           20.10.2
 API version:       1.41
 Go version:        go1.13.15
 Git commit:        2291f61
 Built:             Mon Dec 28 16:17:34 2020
 OS/Arch:           linux/amd64
 Context:           binaries
 Experimental:      true

Server: Docker Engine - Community
 Engine:
  Version:          20.10.2
  API version:      1.41 (minimum version 1.12)
  Go version:       go1.13.15
  Git commit:       8891c58
  Built:            Mon Dec 28 16:15:23 2020
  OS/Arch:          linux/amd64
  Experimental:     false
 containerd:
  Version:          v1.4.3
  GitCommit:        269548fa27e0089a8b8278fc4fc781d7f65a939b
 runc:
  Version:          1.0.0-rc92
  GitCommit:        ff819c7e9184c13b7c2607fe6c30ae19403a7aff
 docker-init:
  Version:          0.19.0
  GitCommit:        de40ad0

# Start a container
docker run --rm -d -p 8080:80 nginx

# Verify images
docker image ls
REPOSITORY   TAG       IMAGE ID       CREATED        SIZE
nginx        latest    35c43ace9216   42 hours ago   133MB

# Verify running containers at remote machine
docker ps
CONTAINER ID   IMAGE     COMMAND                  CREATED          STATUS          PORTS                  NAMES
215e19f876c1   nginx     "/docker-entrypoint.…"   27 seconds ago   Up 24 seconds   0.0.0.0:8080->80/tcp   optimistic_driscoll

# Verify the service is running
curl 192.168.137.39:8080
HTTP/1.1 200 OK
Server: nginx/1.19.7
Date: Fri, 19 Feb 2021 13:20:13 GMT
Content-Type: text/html
Content-Length: 612
Last-Modified: Tue, 16 Feb 2021 15:57:18 GMT
Connection: keep-alive
ETag: "602beb5e-264"
Accept-Ranges: bytes 
```

### Using TCP Socket without TLS

To demostrate the use of using Unix socket with SSL, lets access the `installation/getdc` VM. 

This system uses systemctl to manage docker daemon. First verify the deamon status. And docker socket unit file.

```bash
# Daemon status
systemctl status docker
● docker.service - Docker Application Container Engine
     Loaded: loaded (/lib/systemd/system/docker.service; enabled; vendor preset: enabled)
     Active: active (running) since Fri 2021-02-19 13:28:57 UTC; 44s ago
TriggeredBy: ● docker.socket
       Docs: https://docs.docker.com
   Main PID: 9196 (dockerd)
      Tasks: 10
     Memory: 41.4M
     CGroup: /system.slice/docker.service
             └─9196 /usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock
# Unit file
sudo systemctl cat docker.socket
# /lib/systemd/system/docker.socket
[Unit]
Description=Docker Socket for the API

[Socket]
ListenStream=/var/run/docker.sock
SocketMode=0660
SocketUser=root
SocketGroup=docker

[Install]
WantedBy=sockets.target
```

Next, adjust the socket unit file. 
```bash
sudo systemctl edit docker.socket
```

```
[Socket]
ListenStream=
ListenStream=0.0.0.0:2375
```

Restart and verify the socket unit.
```bash
# Restart the socket
sudo systemctl restart docker.socket
# Verify the socket
● docker.socket - Docker Socket for the API
     Loaded: loaded (/lib/systemd/system/docker.socket; enabled; vendor preset: enabled)
    Drop-In: /etc/systemd/system/docker.socket.d
             └─override.conf
     Active: active (running) since Fri 2021-02-19 13:42:41 UTC; 34s ago
   Triggers: ● docker.service
     Listen: 0.0.0.0:2375 (Stream)
      Tasks: 0 (limit: 2204)
     Memory: 60.0K
     CGroup: /system.slice/docker.socket

Feb 19 13:42:41 getdc systemd[1]: Starting Docker Socket for the API.
Feb 19 13:42:41 getdc systemd[1]: Listening on Docker Socket for the API.

# Verify with docker client
docker -H tcp:// version | grep Server -A17
Server: Docker Engine - Community
 Engine:
  Version:          20.10.3
  API version:      1.41 (minimum version 1.12)
  Go version:       go1.13.15
  Git commit:       46229ca
  Built:            Fri Jan 29 14:31:32 2021
  OS/Arch:          linux/amd64
  Experimental:     false
 containerd:
  Version:          1.4.3
  GitCommit:        269548fa27e0089a8b8278fc4fc781d7f65a939b
 runc:
  Version:          1.0.0-rc92
  GitCommit:        ff819c7e9184c13b7c2607fe6c30ae19403a7aff
 docker-init:
  Version:          0.19.0
  GitCommit:        de40ad0
```

Exposing unprotected API access to docker deamon comes with great security implication. Anybody who has TCP reachability to the exposed port can perform any sort of operation. From pulling down images, launching containers and retrieve information about server. More example of this capability can be found in `scrips/api-security.sh` file.


### Using TCP Socket with TLS

To demostrate the process of securing access to docker API we are going to leverage a new Vagrant box available at `installation/secured`.

```bash
cd installation/secured
vagrant up
...
[ Output omitted for brevity ]
...
```

#### Configuring CA

Once the machine boots and completes the provisioning scripts, log in using `vagrant ssh` and start with create CA configuration.

```bash
vagrant ssh
# Start mkcert and observe the output
mkcert
Created a new local CA 💥
Note: the local CA is not installed in the system trust store.
Run "mkcert -install" for certificates to be trusted automatically ⚠️
Usage of mkcert:

        $ mkcert -install
        Install the local CA in the system trust store.

        $ mkcert example.org
        Generate "example.org.pem" and "example.org-key.pem".

        $ mkcert example.com myapp.dev localhost 127.0.0.1 ::1
        Generate "example.com+4.pem" and "example.com+4-key.pem".

        $ mkcert "*.example.it"
        Generate "_wildcard.example.it.pem" and "_wildcard.example.it-key.pem".

        $ mkcert -uninstall
        Uninstall the local CA (but do not delete it).

For more options, run "mkcert -help".

# Location of CA Certification and key
ls $(mkcert -CAROOT)
```

#### Managing Certificates

Generate new certificate for server

```bash
# Generate certificate for Docker server
mkcert secured $(ip addr show eth0 | grep "inet\b" | awk '{print $2}' | cut -d/ -f1) localhost 127.0.0.1 
Note: the local CA is not installed in the system trust store.
Run "mkcert -install" for certificates to be trusted automatically ⚠️

Created a new certificate valid for the following names 📜
 - "secured"
 - "192.168.137.21"
 - "localhost"
 - "127.0.0.1"

The certificate is at "./secured+3.pem" and the key at "./secured+3-key.pem" ✅

It will expire on 22 May 2023 🗓
```

Generate new certificate for client(s). In this case its the host machine you are using to access Vagrant boxes.

```bash
# Generate certificate for Docker client #1
DOCKER_CLIENT=`echo $SSH_CLIENT | awk '{ print $1 }'`
mkcert -client $DOCKER_CLIENT
Note: the local CA is not installed in the system trust store.
Run "mkcert -install" for certificates to be trusted automatically ⚠️

Created a new certificate valid for the following names 📜
 - "192.168.137.1"

The certificate is at "./192.168.137.1-client.pem" and the key at "./192.168.137.1-client-key.pem" ✅

It will expire on 22 May 2023 🗓

# Generate certificate for Docker client #2
mkcert -client 127.0.0.1 localhost
Note: the local CA is not installed in the system trust store.
Run "mkcert -install" for certificates to be trusted automatically ⚠️

Created a new certificate valid for the following names 📜
 - "127.0.0.1"
 - "localhost"

The certificate is at "./127.0.0.1+1-client.pem" and the key at "./127.0.0.1+1-client-key.pem" ✅

It will expire on 22 May 2023 🗓
```

#### Configuring docker deamon

While still on the `secured` machine, start the docker daemon with host arguments to enable TSL.
```bash
# Start docker deamon with TLS
sudo dockerd --tlsverify \
        --tlscacert $(mkcert -CAROOT)/rootCA.pem \
        --tlscert ./secured+3.pem \
        --tlskey ./secured+3-key.pem \
        -H 0.0.0.0:2376
...
INFO[2021-02-22T12:42:19.980260555Z] Daemon has completed initialization
INFO[2021-02-22T12:42:20.001613344Z] API listen on [::]:2376
...
```

#### Testing locally with docker client

Open a new windows on the `secured` machine, and verify that you can connect to deamon from local client.
```bash
docker --tlsverify \
       --tlscacert $(mkcert -CAROOT)/rootCA.pem \
       --tlscert ./127.0.0.1+1-client.pem \
       --tlskey ./127.0.0.1+1-client-key.pem \
       -H 127.0.0.1:2376 \
       info

Client:
 Context:    default
 Debug Mode: false

# The following output should be returned
Server:
 Containers: 0
  Running: 0
  Paused: 0
  Stopped: 0
 Images: 0
 Server Version: 20.10.2
 Storage Driver: overlay2
...
```

Finally to simplify the docker client configuration, create a new context:
```bash
docker context create secured --description "Secured connection from localhost" --docker "host=tcp://127.0.0.1:2376,ca=$(mkcert -CAROOT)/rootCA.pem,cert=./127.0.0.1+1-client.pem,key=./127.0.0.1+1-client-key.pem"
secured
Successfully created context "secured"

# Retry with context
docker context use secured
docker info
Client:
 Context:    secured
 Debug Mode: false

Server:
 Containers: 0
  Running: 0
  Paused: 0
  Stopped: 0
 Images: 0
 Server Version: 20.10.2
 Storage Driver: overlay2
```

#### Testing locally with curl

To confirm that the API is secured, retry the curl requests described in `scripts/api-security.sh`.

```bash
# Try simple GET request to HTTP Server
curl http://127.0.0.1:2376/info
Client sent an HTTP request to an HTTPS server.

# Try simple GET request to HTTPS Server
curl https://127.0.0.1:2376/info
curl: (60) SSL certificate problem: unable to get local issuer certificate
More details here: https://curl.haxx.se/docs/sslcerts.html

curl failed to verify the legitimacy of the server and therefore could not
establish a secure connection to it. To learn more about this situation and
how to fix it, please visit the web page mentioned above.

# Try with CA Certificate
curl --cacert $(mkcert -CAROOT)/rootCA.pem \
     https://127.0.0.1:2376/info
curl: (56) OpenSSL SSL_read: error:14094412:SSL routines:ssl3_read_bytes:sslv3 alert bad certificate, errno 0

# Try with CA Certificate and Client Certificate
curl --cacert $(mkcert -CAROOT)/rootCA.pem \
     --cert ./127.0.0.1+1-client.pem \
     --key ./127.0.0.1+1-client-key.pem \
     --silent \
     https://127.0.0.1:2376/info

# Output 
{"ID":"QYSP:2MLM:FTY2:BUE4:3CV3:CSOP:T3DO:N2TU:MNS7:MSRR:Q5CA:CSIK","Containers":0,"ContainersRunning":0,"ContainersPaused":0,"ContainersStopped":0,"Images":0,"Driver":"overlay2","DriverStatus":[["Backing Filesystem","extfs"],["Supports d_type","true"],["Native Overlay Diff","true"]],"Plugins":{"Volume":["local"],"Network":["bridge
...
```

In the above example, by using `cacert` option client is verifying the server certificate. It is not mandatory, and can be skipped if `--insecure` option is used:
```bash
curl --insecure \
     --cert ./127.0.0.1+1-client.pem \
     --key ./127.0.0.1+1-client-key.pem \
     --silent \
     https://127.0.0.1:2376/info

# Output
{"ID":"QYSP:2MLM:FTY2:BUE4:3CV3:CSOP:T3DO:N2TU:MNS7:MSRR:Q5CA:CSIK","Containers":0,"ContainersRunning":0,"ContainersPaused":0,"ContainersStopped":0,"Images":0,"Driver":"overlay2","DriverStatus":[["Backing Filesystem","extfs"],["Supports d_type","true"],["Native Overlay Diff","true"]],"Plugins":{"Volume":["local"],"Network":["bridge
...
```

#### Testing remotely with docker client

In the [Managing Certificates](Managing-Certificates) section, you generated certificate and key for the host machine. Now its time to test this credentials agains the docker server running on `secured` vagrant machine.

Start by gettings these generated credentials to your host machine.
```bash
cd installation/secured

# Generate SSH config 
vagrant ssh-config > ~/.ssh/vagrants/secured.config

# Download CA Certificate and Client Certificate and key
scp -r vagrant@secured:~/.local/share/mkcert/rootCA.pem .
scp -r vagrant@secured:~/192.168.137.1-client.pem .
scp -r vagrant@secured:~/192.168.137.1-client-key.pem .

# Verify with docker client
SECURED_IP=192.168.137.21
docker --tlsverify \
       --tlscacert ./rootCA.pem \
       --tlscert ./192.168.137.1-client.pem \
       --tlskey ./192.168.137.1-client-key.pem \
       -H ${SECURED_IP}:2376 \
       info

Client:
 Context:    default
 Debug Mode: false
 Plugins:
  app: Docker App (Docker Inc., v0.9.1-beta3)
  buildx: Build with BuildKit (Docker Inc., v0.5.1-docker)
  scan: Docker Scan (Docker Inc., v0.5.0)

Server:
 Containers: 0
  Running: 0
  Paused: 0
  Stopped: 0
 Images: 0

...
```

#### Testing remotely with curl

```bash
# Verify with curl
SECURED_IP=192.168.137.21
curl --cacert ./rootCA.pem \
     --cert ./192.168.137.1-client.pem \
     --key ./192.168.137.1-client-key.pem \
     --silent \
     https://$SECURED_IP:2376/info \
     | jq

"ID": "QYSP:2MLM:FTY2:BUE4:3CV3:CSOP:T3DO:N2TU:MNS7:MSRR:Q5CA:CSIK",
  "Containers": 0,
  "ContainersRunning": 0,
  "ContainersPaused": 0,
  "ContainersStopped": 0,
  "Images": 0,
  "Driver": "overlay2",
  "DriverStatus": [
    [
      "Backing Filesystem",
      "extfs"
    ],
    [
      "Supports d_type",
      "true"
    ],
    [
      "Native Overlay Diff",
      "true"
    ]
...
```

#### Creating docker context 

Again, you can configure `docker context` to simplify the usage.

```bash
docker context create secured \
--description "Secured connection from remote client" \
--docker "host=tcp://$SECURED_IP:2376,ca=./rootCA.pem,cert=./192.168.137.1-client.pem,key=./192.168.137.1-client-key.pem"
secured
Successfully created context "secured"

# Use the new context
docker context use secured

# Verify the configuration
docker info
Client:
 Context:    secured
 Debug Mode: false
 Plugins:
  app: Docker App (Docker Inc., v0.9.1-beta3)
  buildx: Build with BuildKit (Docker Inc., v0.5.1-docker)
  scan: Docker Scan (Docker Inc., v0.5.0)

Server:
 Containers: 0
  Running: 0
  Paused: 0
  Stopped: 0
 Images: 0
 Server Version: 20.10.2
```

