# docker-on-linux

- [docker-on-linux](#docker-on-linux)
  - [Introduction](#introduction)
  - [Documentation](#documentation)
  - [Installation](#installation)
    - [Option A - Manual Provisioning](#option-a---manual-provisioning)
      - [Create Virtual Machine](#create-virtual-machine)
      - [Uninstall old versions](#uninstall-old-versions)
      - [Set up the repository](#set-up-the-repository)
      - [Install Docker Engine](#install-docker-engine)
      - [Start Dockear daemon](#start-dockear-daemon)
      - [Adding User to docker group](#adding-user-to-docker-group)
      - [Enable Docker service on boot](#enable-docker-service-on-boot)
      - [Verification](#verification)
    - [Option B - Bash Provisioning](#option-b---bash-provisioning)
      - [Create Virtual Machine](#create-virtual-machine-1)
    - [Option C - Ansible Provisioning](#option-c---ansible-provisioning)
      - [Create Virtual Machine](#create-virtual-machine-2)
  - [Docker Contexts](#docker-contexts)
    - [Namespaces](#namespaces)
    - [Contexts](#contexts)
    - [Docker Snap](#docker-snap)
    - [Docker Binaries](#docker-binaries)
    - [Docker remote connection](#docker-remote-connection)
      - [Running remote containers](#running-remote-containers)

## Introduction

## Documentation

- [Namespaces](https://man7.org/linux/man-pages/man7/namespaces.7.html)
- [Nsenter](https://man7.org/linux/man-pages/man1/nsenter.1.html)
- [Docker Hub](https://hub.docker.com/)
- [Docker Binaries](https://docs.docker.com/engine/install/binaries/)
- [Snapcraft Docker](https://snapcraft.io/docker)


## Installation

In order to create Virtual Machines in declarative way, using VagrantFile, you first need to install the tool itself and a hypervisor of your choice.

- [Vagrant Project](https://www.vagrantup.com/)
- [VirtualBox](https://www.virtualbox.org/)
- [Hyper-V on Windows 10](https://docs.microsoft.com/en-us/virtualization/hyper-v-on-windows/quick-start/enable-hyper-v)

Since I am using a Windows environment with [WSL2](https://devblogs.microsoft.com/commandline/wsl2-will-be-generally-available-in-windows-10-version-2004/) enabled. I will describe the steps using Hyper-V as hypervisor provider for Vagrant.

### Option A - Manual Provisioning

#### Create Virtual Machine

Start by initializing the Vagrantfile with default values using the official [Centos 7 Vagrant box](https://app.vagrantup.com/centos/boxes/7). 

```bash
cd installation/centos-7
vagrant init centos/7
vagrant up
Bringing machine 'default' up with 'hyperv' provider...
==> default: Verifying Hyper-V is enabled...
==> default: Verifying Hyper-V is accessible...
==> default: Box 'centos/7' could not be found. Attempting to find and install...
    default: Box Provider: hyperv
    default: Box Version: >= 0
==> default: Loading metadata for box 'centos/7'
    default: URL: https://vagrantcloud.com/centos/7
==> default: Adding box 'centos/7' (v2004.01) for provider: hyperv
    default: Downloading: https://vagrantcloud.com/centos/boxes/7/versions/2004.01/providers/hyperv.box
Download redirected to host: cloud.centos.org
Progress: 2% (Rate: 3825k/s, Estimated time remaining: 0:02:29)
[ Output omitted for brevity]
```

Once the box is up and running, use `vagrant ssh` which is a wrapper that leverages SSH configuration that was generated by Vagrant. Details are available at `vagrant ssh-config`.

```bash
vagrant ssh
# Verify user
[vagrant@localhost ~]$ id
uid=1000(vagrant) gid=1000(vagrant) groups=1000(vagrant) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023
[vagrant@localhost ~]$ groups
vagrant
# Verify release
[vagrant@localhost ~]$ cat /etc/*release
CentOS Linux release 7.8.2003 (Core)
NAME="CentOS Linux"
VERSION="7 (Core)"
ID="centos"
ID_LIKE="rhel fedora"
VERSION_ID="7"
PRETTY_NAME="CentOS Linux 7 (Core)"
ANSI_COLOR="0;31"
CPE_NAME="cpe:/o:centos:centos:7"
HOME_URL="https://www.centos.org/"
BUG_REPORT_URL="https://bugs.centos.org/"

CENTOS_MANTISBT_PROJECT="CentOS-7"
CENTOS_MANTISBT_PROJECT_VERSION="7"
REDHAT_SUPPORT_PRODUCT="centos"
REDHAT_SUPPORT_PRODUCT_VERSION="7"

CentOS Linux release 7.8.2003 (Core)
CentOS Linux release 7.8.2003 (Core)
```

To install Docker, we are going to follow the [Install Docker Engine on CentOS](https://docs.docker.com/engine/install/centos/). From the guest shell follow these procedures to install docker on Centos 7.

#### Uninstall old versions

```bash
sudo yum remove docker \
                  docker-client \
                  docker-client-latest \
                  docker-common \
                  docker-latest \
                  docker-latest-logrotate \
                  docker-logrotate \
                  docker-engine
```

#### Set up the repository

```bash
sudo yum install -y yum-utils
sudo yum-config-manager \
    --add-repo \
    https://download.docker.com/linux/centos/docker-ce.repo
```

#### Install Docker Engine

Install the `docker-ce`, `docker-ce-cli` and `containerd.io`.
```bash
sudo yum install -y docker-ce docker-ce-cli containerd.io
```

Verify the that `docker` command is available.
```bash
docker version
Client: Docker Engine - Community
 Version:           20.10.3
 API version:       1.41
 Go version:        go1.13.15
 Git commit:        48d30b5
 Built:             Fri Jan 29 14:34:14 2021
 OS/Arch:           linux/amd64
 Context:           default
 Experimental:      true
Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?
```

Verify that the docker deamon is running.
```bash
ls /var/run | grep docker.sock

# Check service status using system manager
systemctl status docker.service
● docker.service - Docker Application Container Engine
   Loaded: loaded (/usr/lib/systemd/system/docker.service; disabled; vendor preset: disabled)
   Active: inactive (dead)
     Docs: https://docs.docker.com

systemctl status docker.socket
● docker.socket - Docker Socket for the API
   Loaded: loaded (/usr/lib/systemd/system/docker.socket; disabled; vendor preset: disabled)
   Active: inactive (dead)
   Listen: /var/run/docker.sock (Stream)
```

#### Start Dockear daemon

```bash
sudo systemctl start docker
# Rerun the systemctl status for docker.service and docker.host to verify that both services are running
systemctl status docker.service
● docker.service - Docker Application Container Engine
   Loaded: loaded (/usr/lib/systemd/system/docker.service; disabled; vendor preset: disabled)
   Active: active (running) since Wed 2021-02-17 13:37:54 UTC; 1min 42s ago
     Docs: https://docs.docker.com
 Main PID: 20902 (dockerd)
    Tasks: 8
   Memory: 43.5M
   CGroup: /system.slice/docker.service
           └─20902 /usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock

systemctl status docker.socket
● docker.socket - Docker Socket for the API
   Loaded: loaded (/usr/lib/systemd/system/docker.socket; disabled; vendor preset: disabled)
   Active: active (running) since Wed 2021-02-17 13:37:53 UTC; 1min 46s ago
   Listen: /var/run/docker.sock (Stream)
```

As you see from above output the socket `/var/run/docker.sock` is now available. You can verify that also using:
```bash
ls /var/run | grep docker.sock
docker.sock
```

Now back to `docker version` the output is different and indicates that the current user does not have permissions to access the socket.
```bash
docker version
Client: Docker Engine - Community
 Version:           20.10.3
 API version:       1.41
 Go version:        go1.13.15
 Git commit:        48d30b5
 Built:             Fri Jan 29 14:34:14 2021
 OS/Arch:           linux/amd64
 Context:           default
 Experimental:      true
Got permission denied while trying to connect to the Docker daemon socket at unix:///var/run/docker.sock: Get http://%2Fvar%2Frun%2Fdocker.sock/v1.24/version: dial unix /var/run/docker.sock: connect: permission denied
```

The reason is that the socket permissins does not allow `vagrant:vagrant` to access it.
```
ls -al /var/run/docker.sock
srw-rw----. 1 root docker 0 Feb 17 13:37 /var/run/docker.sock
```

To fix this, we have two available options:
- Elavate permissions using `sudo` everytime `docker` is invoked
- Add `vagrant` user to `docker` group.

Lets perform the second option.

#### Adding User to docker group

```bash
sudo usermod -aG docker vagrant
```

You need to logout and login to apply this change
```bash
# Verify the user groups
groups
vagrant docker
```

With this change, user has proper access to invoke `docker version` and retrieve information for client and server.
```bash
[vagrant@localhost ~]$ groups
vagrant docker
[vagrant@localhost ~]$ docker version
Client: Docker Engine - Community
 Version:           20.10.3
 API version:       1.41
 Go version:        go1.13.15
 Git commit:        48d30b5
 Built:             Fri Jan 29 14:34:14 2021
 OS/Arch:           linux/amd64
 Context:           default
 Experimental:      true

Server: Docker Engine - Community
 Engine:
  Version:          20.10.3
  API version:      1.41 (minimum version 1.12)
  Go version:       go1.13.15
  Git commit:       46229ca
  Built:            Fri Jan 29 14:32:37 2021
  OS/Arch:          linux/amd64
  Experimental:     false
 containerd:
  Version:          1.4.3
  GitCommit:        269548fa27e0089a8b8278fc4fc781d7f65a939b
 runc:
  Version:          1.0.0-rc92
  GitCommit:        ff819c7e9184c13b7c2607fe6c30ae19403a7aff
 docker-init:
  Version:          0.19.0
  GitCommit:        de40ad0
```

#### Enable Docker service on boot

Verify the current state and configuration summary of systemctl unit-files for docker:
```bash
systemctl list-unit-files | grep docker
docker.service                                disabled
docker.socket                                 disabled
```

To enable both services update the systemctl configuration.
```bash
sudo systemctl enable docker
Created symlink from /etc/systemd/system/multi-user.target.wants/docker.service to /usr/lib/systemd/system/docker.service.

# You can verify that docker.socket and containerd.service are dependencies for docker.service
cat /etc/systemd/system/multi-user.target.wants/docker.service | grep Requires
Requires=docker.socket containerd.service
```

To verify the which unit files are related to docker packages you can use `rpm -ql docker-ce`.
```bash
rpm -ql docker-ce
/usr/bin/docker-init
/usr/bin/docker-proxy
/usr/bin/dockerd
/usr/lib/systemd/system/docker.service
/usr/lib/systemd/system/docker.socket
```

You can use this method for other packages that were installed previously.

#### Verification

Reload the VM in order to make sure that docker deamon will start automatically. Use `vagrant reload` from the Host machine.
Once the machie boots, access it ssh and execute `docker version`.
```
vagrant reload
```


### Option B - Bash Provisioning

#### Create Virtual Machine

Start by initializing the Vagrantfile with default values using the [Centos 8 Vagrant box](https://app.vagrantup.com/centos/boxes/8)provided by generic. 

```bash
cd installation/centos-8
vagrant init centos/8
```

Open your favorite code editor and configure provisioning option in Vagrantfile.

```ruby
Vagrant.configure("2") do |config|
  config.vm.box = "centos/8"
  config.vm.provision "shell", path: "provision.sh"
```

Save the file, and create a new file `provision.sh` in same directory. You can leverage the script that is available at [get.docker](https://get.docker.com/) or you can write your own custom script. One modifycation I made was to start service automatically.

With both files ready, start with `vagrant up`.

```bash
vagrant up
Bringing machine 'default' up with 'hyperv' provider...                                                                              ==> default: Verifying Hyper-V is enabled...
==> default: Verifying Hyper-V is accessible...
==> default: Importing a Hyper-V instance
    default: Creating and registering the VM...
    default: Successfully imported VM
[ Output omitted for brevity]
==> default: Machine booted and ready!
==> default: Running provisioner: shell...
    default: Running: /tmp/vagrant-shell20210217-18571-ai2mvr.sh
    default: # Executing docker install script, commit: 3d8fe77c2c46c5b7571f94b42793905e5b3e42e4
    default: + sh -c 'yum install -y -q yum-utils'
    default: + sh -c 'yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo'
    default: Adding repo from: https://download.docker.com/linux/centos/docker-ce.repo
    default: + '[' stable '!=' stable ']'
    default: + sh -c 'yum makecache'
    default: CentOS Linux 8 - AppStream                       26 kB/s | 4.3 kB     00:00
    default: CentOS Linux 8 - BaseOS                          23 kB/s | 3.9 kB     00:00
    default: CentOS Linux 8 - Extras                         8.7 kB/s | 1.5 kB     00:00
    default: Docker CE Stable - x86_64                        30 kB/s | 9.2 kB     00:00
    default: Extra Packages for Enterprise Linux Modular 8 - 122 kB/s |  33 kB     00:00
    default: Extra Packages for Enterprise Linux 8 - x86_64   93 kB/s |  23 kB     00:00
    default: Metadata cache created.
```

Once the box is up and running, use `vagrant ssh` and verify that docker was sucessfully installed.

```bash
vagrant ssh
docker version
Client: Docker Engine - Community
 Version:           20.10.3
 API version:       1.41
 Go version:        go1.13.15
 Git commit:        48d30b5
 Built:             Fri Jan 29 14:33:08 2021
 OS/Arch:           linux/amd64
 Context:           default
 Experimental:      true

Server: Docker Engine - Community
 Engine:
  Version:          20.10.3
  API version:      1.41 (minimum version 1.12)
  Go version:       go1.13.15
  Git commit:       46229ca
  Built:            Fri Jan 29 14:31:25 2021
  OS/Arch:          linux/amd64
  Experimental:     false
 containerd:
  Version:          1.4.3
  GitCommit:        269548fa27e0089a8b8278fc4fc781d7f65a939b
 runc:
  Version:          1.0.0-rc92
  GitCommit:        ff819c7e9184c13b7c2607fe6c30ae19403a7aff
 docker-init:
  Version:          0.19.0
  GitCommit:        de40ad0
```


### Option C - Ansible Provisioning

#### Create Virtual Machine

Start by initializing the Vagrantfile with default values using the [Ubuntu 20.04 Vagrant box](https://app.vagrantup.com/generic/boxes/ubuntu2004) provided by geenric. 

```bash
cd installation/ubuntu-20.04
vagrant init generic/ubuntu2004
```

Open your favorite code editor and configure provisioning option in Vagrantfile.

```ruby
Vagrant.configure("2") do |config|
  config.vm.box = "centos/8"
  config.vm.provision "ansible" do |ansible|
    ansible.playbook = "playbook.yml"
```

Save the file, and create a new file `playbook.yml` in same directory. 

```yml

```

It is good practice to verify the playbook syntax with `ansible-playbook playbook.yml --syntax-check`.
```bash
[WARNING]: provided hosts list is empty, only localhost is available. Note that the implicit localhost does not match 'all'

playbook: playbook.yml
```

With both files ready, start with `vagrant up`.

```bash
vagrant up
Bringing machine 'default' up with 'hyperv' provider...
==> default: Verifying Hyper-V is enabled...
==> default: Verifying Hyper-V is accessible...
==> default: Importing a Hyper-V instance
[ Output omitted for brevity]
==> default: Machine booted and ready!
==> default: Running provisioner: ansible...
    default: Running ansible-playbook...

PLAY [all] *********************************************************************

TASK [Gathering Facts] *********************************************************
ok: [default]

TASK [install prerequisites] ***************************************************
changed: [default]

TASK [add apt-key] *************************************************************
changed: [default]

TASK [add docker repo] *********************************************************
changed: [default]

TASK [install docker] **********************************************************
changed: [default]

TASK [add userpermissions] *****************************************************
changed: [default]

PLAY RECAP *********************************************************************
default                    : ok=6    changed=4    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0
```

Once the box is up and running, use `vagrant ssh` and verify that docker was sucessfully installed.

```bash
vagrant ssh
docker version
Client: Docker Engine - Community
 Version:           20.10.3
 API version:       1.41
 Go version:        go1.13.15
 Git commit:        48d30b5
 Built:             Fri Jan 29 14:33:21 2021
 OS/Arch:           linux/amd64
 Context:           default
 Experimental:      true

Server: Docker Engine - Community
 Engine:
  Version:          20.10.3
  API version:      1.41 (minimum version 1.12)
  Go version:       go1.13.15
  Git commit:       46229ca
  Built:            Fri Jan 29 14:31:32 2021
  OS/Arch:          linux/amd64
  Experimental:     false
 containerd:
  Version:          1.4.3
  GitCommit:        269548fa27e0089a8b8278fc4fc781d7f65a939b
 runc:
  Version:          1.0.0-rc92
  GitCommit:        ff819c7e9184c13b7c2607fe6c30ae19403a7aff
 docker-init:
  Version:          0.19.0
  GitCommit:        de40ad0
```


## Docker Contexts

Before we start with Docker contexts, lets understand the path that docker command takes to execute action upon a container. By default the following components will be involved:

1. docker command
2. Unix socket (IPC) to API, root:docker
3. Docker Engine API (Create container, list images, etc.)
4. Docker Engine daemon (dockerd) executes incomming API task / queries
5. Containers (isolated processes) and associated resources such as: images, mounts/filesystems, networking, processes, cgroups, security

Since the architecture is modular, it is possible to use multiple docker enginer API behind an Unix or TCP socket and therefore provide remote access to multiple (local, test, prod) docker engine daemons. Before doing so, lets review the fundamental building block of containers - linux namespaces.

### Namespaces

In summary, Docker provides a level of abstraction for underlying linux features such as namespaces. To work with namespaces directly, first create a new container inside previously provisioned Vagrant machine with docker installed.
```bash
docker run --rm -it bash
```
You will end up inside a docker container. Leave this terminal window open.

Back on VM with docker installed, open a new terminal and explore the use of `nsenter` command.
```bash
# Retrieve the Process ID for Container ID 3af2....
sudo docker inspect --format {{.State.Pid}} 3af2
7071
# Enter the namespace for target process 7071
sudo nsenter --target 7071 --mount --uts --ipc --net --pid /usr/local/bin/bash
```

### Contexts

Start by provisioning and verify a `cli-only` installation. 

```bash
cd installation/cli-only
vagrant up
[ Output omitted for brevity]
# Once the machine boots, login via vagrant ssh and verify the status,
docker info
Client:
 Context:    default
 Debug Mode: false
 Plugins:
  app: Docker App (Docker Inc., v0.9.1-beta3)
  buildx: Build with BuildKit (Docker Inc., v0.5.1-docker)

Server:
ERROR: Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?
errors pretty printing info
```

As expected, there is no docker daemon installed.

Provision and verify full docker install on `getdc`.

```bash
cd installation/getdc
vagrant up
[ Output omitted for brevity]
# Once the machine boots, login via vagrant ssh and verify the status,
docker info
Client: Docker Engine - Community
 Version:           20.10.3
 API version:       1.41
 Go version:        go1.13.15
 Git commit:        48d30b5
 Built:             Fri Jan 29 14:33:21 2021
 OS/Arch:           linux/amd64
 Context:           default
 Experimental:      true

Server: Docker Engine - Community
 Engine:
  Version:          20.10.3
  API version:      1.41 (minimum version 1.12)
  Go version:       go1.13.15
  Git commit:       46229ca
  Built:            Fri Jan 29 14:31:32 2021
  OS/Arch:          linux/amd64
  Experimental:     false
 containerd:
  Version:          1.4.3
  GitCommit:        269548fa27e0089a8b8278fc4fc781d7f65a939b
 runc:
  Version:          1.0.0-rc92
  GitCommit:        ff819c7e9184c13b7c2607fe6c30ae19403a7aff
 docker-init:
  Version:          0.19.0
  GitCommit:        de40ad0
  ```

Lets jump back to `cli-only` VM by using `vagrant ssh` in the correct folder. 

Verify the default docker context.

```bash
vagrant ssh
# Verify the context configuration
docker context ls
NAME        DESCRIPTION                               DOCKER ENDPOINT               KUBERNETES ENDPOINT   ORCHESTRATOR
default *   Current DOCKER_HOST based configuration   unix:///var/run/docker.sock                         swarm

# Inspect the context configuration
docker context inspect
[
    {
        "Name": "default",
        "Metadata": {
            "StackOrchestrator": "swarm"
        },
        "Endpoints": {
            "docker": {
                "Host": "unix:///var/run/docker.sock",
                "SkipTLSVerify": false
            }
        },
        "TLSMaterial": {},
        "Storage": {
            "MetadataPath": "\u003cIN MEMORY\u003e",
            "TLSPath": "\u003cIN MEMORY\u003e"
        }
    }
]
```

As you can see from above output, the default context points to Unix socket, which in this case is not available as we did not install docker daemon this machine.

Lets distroy these two machines by using `vagrant destroy --force`.

### Docker Snap

Docker is also available as [snap package](https://snapcraft.io/docker) provided by `snapcraft`. A Vagrantfile with the shell provision script is available at `installation/snappy` folder. Start the machine with `vagrant up`, once prepared enter the machine `vagrant ssh` and verify that docker is installed.

```bash
docker version
Client:
 Version:           19.03.13
 API version:       1.40
 Go version:        go1.13.15
 Git commit:        cd8016b6bc
 Built:             Fri Feb  5 15:56:39 2021
 OS/Arch:           linux/amd64
 Experimental:      false

Server:
 Engine:
  Version:          19.03.13
  API version:      1.40 (minimum version 1.12)
  Go version:       go1.13.15
  Git commit:       bd33bbf
...
[ Output omitted for brevity ]
...
```

### Docker Binaries

Installing docker engine from [binaries](https://docs.docker.com/engine/install/binaries/) is yet another way how to accomplish what we done in previous steps. 

A Vagrantfile with a shell provision script is avaibale in the `installation/binaries` folder. Start the machine with `vagrant up`, once prepared enter the machine `vagrant ssh`

You can change the default docker daemon configuration by adding arguments such as:
```bash
# Verify which argument deals with Deamon socket configuration
dockerd --help | grep Daemon
      --config-file string                      Daemon configuration file (default "/etc/docker/daemon.json")
  -H, --host list                               Daemon socket(s) to connect to

# Start the dockerd
sudo dockerd -H tcp://
...
[ Output omitted for brevity ]
...
INFO[2021-02-18T18:03:17.648802110Z] Daemon has completed initialization
INFO[2021-02-18T18:03:17.662811079Z] API listen on 127.0.0.1:2375
```

Using a different shell window, you can verify the connection locally.
```bash
# Verify version with Host option
docker -H tcp:// version
Client: Docker Engine - Community
 Version:           20.10.2
 API version:       1.41
 Go version:        go1.13.15
 Git commit:        2291f61
 Built:             Mon Dec 28 16:11:26 2020
 OS/Arch:           linux/amd64
 Context:           default
 Experimental:      true

Server: Docker Engine - Community
 Engine:
  Version:          20.10.2
  API version:      1.41 (minimum version 1.12)
  Go version:       go1.13.15
  Git commit:       8891c58
...
[ Output omitted for brevity ]
...
# Verify context with Host option
docker -H tcp:// context ls
NAME        DESCRIPTION                               DOCKER ENDPOINT        KUBERNETES ENDPOINT   ORCHESTRATOR
default *   Current DOCKER_HOST based configuration   tcp://localhost:2375                         swarm
```  

You can also use `DOCKER_HOST` variable with `docker` client like this:
```bash
# Using variable one time
DOCKER_HOST=tcp:// docker context ls
DOCKER_HOST=tcp:// docker version
```

The local connection over TCP at `127.0.0.1:2375` will now work. To enable remote connection, we need to change the configuration to bind to all addresses. Please note however this method is **insecure**.

```basg
sudo dockerd -H tcp://0.0.0.0:2375
...
[ Output omitted for brevity ]
...
INFO[2021-02-18T18:54:37.180895456Z] Daemon has completed initialization
INFO[2021-02-18T18:54:37.194794629Z] API listen on [::]:2375
```

### Docker remote connection

Back on `snappy` client machine, configure the `DOCKER_HOST` to point to remote `binaries` docker server. Then validate the connection.

```bash
# Update environment variable
export DOCKER_HOST=tcp://192.168.137.39:2375

# Verify that you can connect to remote docker server
docker version
Client:
 Version:           19.03.13
 API version:       1.40
 Go version:        go1.13.15
 Git commit:        cd8016b6bc
 Built:             Fri Feb  5 15:56:39 2021
 OS/Arch:           linux/amd64
 Experimental:      false

Server: Docker Engine - Community
 Engine:
  Version:          20.10.2
  API version:      1.41 (minimum version 1.12)
  Go version:       go1.13.15
  Git commit:       8891c58
  Built:            Mon Dec 28 16:15:23 2020
  OS/Arch:          linux/amd64
  Experimental:     false
 containerd:
  Version:          v1.4.3
  GitCommit:        269548fa27e0089a8b8278fc4fc781d7f65a939b
 runc:
  Version:          1.0.0-rc92
  GitCommit:        ff819c7e9184c13b7c2607fe6c30ae19403a7aff
 docker-init:
  Version:          0.19.0
  GitCommit:        de40ad0
```

#### Running remote containers

Now you can run container on remote docker server host using docker client on `snappy` machine.

```bash
# Run container on remote host
docker run --rm -d -p 8080:80 nginx
Unable to find image 'nginx:latest' locally
latest: Pulling from library/nginx
45b42c59be33: Pull complete
8acc495f1d91: Pull complete
ec3bd7de90d7: Pull complete
19e2441aeeab: Pull complete
f5a38c5f8d4e: Pull complete
83500d851118: Pull complete
Digest: sha256:f3693fe50d5b1df1ecd315d54813a77afd56b0245a404055a946574deb6b34fc
Status: Downloaded newer image for nginx:latest
8fa3f916772a2326a340a9f1935645b00f803ee1942dde4a4c222f9d7902610a

# Verify the container
curl --head 192.168.137.39:8080
HTTP/1.1 200 OK
Server: nginx/1.19.7
Date: Thu, 18 Feb 2021 19:02:59 GMT
Content-Type: text/html
Content-Length: 612
Last-Modified: Tue, 16 Feb 2021 15:57:18 GMT
Connection: keep-alive
ETag: "602beb5e-264"
Accept-Ranges: bytes
```

To avoid specifying connection details every time you invoke a docker command. You can create context for each connection. 

```bash
docker context create binaries --description "Remote testing environemnt" --docker "host=tcp://192.168.137.39:2375"
binaries
Successfully created context "binaries"

# Verify the new context
docker context ls
NAME                DESCRIPTION                               DOCKER ENDPOINT               KUBERNETES ENDPOINT   ORCHESTRATOR
binaries            Remote testing environemnt                tcp://192.168.137.39:2375
default *           Current DOCKER_HOST based configuration   unix:///var/run/docker.sock                         swarm
```

To to switch from `default` to `binaries` context, use the following command.
```bash
docker context use binaries
binaries
Current context is now "binaries"
```

Now every docker client command will by target to the remote docker host.
```bash
# Available images
docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
nginx               latest              35c43ace9216        24 hours ago        133MB

# Running containers
docker ps
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                  NAMES
8fa3f916772a        nginx               "/docker-entrypoint.…"   15 minutes ago      Up 15 minutes       0.0.0.0:8080->80/tcp   dreamy_williams

# Switch to default (local) context
docker context use default
default
Current context is now "default"
```

To export the newly created context, use `export` arguemnt.
```bash
docker context export binaries
Written file "binaries.dockercontext"
# Display content

```

You can later import this connection.
